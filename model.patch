diff --git a/frontend/app/subscription.tsx b/frontend/app/subscription.tsx
index 17c5521..6bd8b40 100644
--- a/frontend/app/subscription.tsx
+++ b/frontend/app/subscription.tsx
@@ -117,15 +117,15 @@ export default function SubscriptionScreen() {
 
       const response = await api.post('/api/subscription/checkout', checkoutData);
       
-      if (response.data.url) {
-        // Redirect to Stripe checkout
+      if (response.data.checkout_url) {
+        // Redirect to Mercado Pago checkout
         if (Platform.OS === 'web') {
           // Check if we're in an iframe (like Expo preview)
           const isInIframe = window !== window.parent;
           
           if (isInIframe) {
             // Open in new window/tab to avoid iframe restrictions
-            const newWindow = window.open(response.data.url, '_blank', 'width=600,height=700');
+            const newWindow = window.open(response.data.checkout_url, '_blank', 'width=600,height=700');
             if (!newWindow) {
               Alert.alert(
                 'Popup Bloqueado',
@@ -133,20 +133,20 @@ export default function SubscriptionScreen() {
                 [
                   {
                     text: 'Tentar Novamente',
-                    onPress: () => window.open(response.data.url, '_blank')
+                    onPress: () => window.open(response.data.checkout_url, '_blank')
                   }
                 ]
               );
             }
           } else {
             // Direct redirect if not in iframe
-            window.location.href = response.data.url;
+            window.location.href = response.data.checkout_url;
           }
         } else {
           // For mobile, you might want to use WebView or similar
           Alert.alert(
             'Redirecionamento para Pagamento',
-            'Voc√™ ser√° redirecionado para a p√°gina de pagamento do Stripe.',
+            'Voc√™ ser√° redirecionado para a p√°gina de pagamento do Mercado Pago.',
             [
               {
                 text: 'Cancelar',
@@ -156,7 +156,7 @@ export default function SubscriptionScreen() {
                 text: 'Continuar',
                 onPress: () => {
                   // Open external URL (this would need proper handling in a real app)
-                  console.log('Redirect to:', response.data.url);
+                  console.log('Redirect to:', response.data.checkout_url);
                 }
               }
             ]
@@ -246,20 +246,20 @@ export default function SubscriptionScreen() {
     }
   };
 
-  // Check for session_id in URL (return from Stripe)
+  // Check for session_id in URL (return from Mercado Pago)
   useEffect(() => {
     if (Platform.OS === 'web') {
       const urlParams = new URLSearchParams(window.location.search);
       const sessionId = urlParams.get('session_id');
       if (sessionId) {
-        console.log('üîô Returned from Stripe with session:', sessionId);
+        console.log('üîô Returned from Mercado Pago with session:', sessionId);
         
         // Clear URL parameters immediately
         window.history.replaceState({}, document.title, window.location.pathname);
         
         // If user is not authenticated, redirect to home with success message
         if (!user) {
-          console.log('üîê No user found after Stripe, assuming successful payment and redirecting to home');
+          console.log('üîê No user found after Mercado Pago, assuming successful payment and redirecting to home');
           Alert.alert(
             'Pagamento Processado!',
             'Seu pagamento foi processado. Fa√ßa login para acessar sua assinatura.',
@@ -444,7 +444,7 @@ export default function SubscriptionScreen() {
         <View style={styles.securityNote}>
           <Ionicons name="shield-checkmark" size={20} color="#6B7280" />
           <Text style={styles.securityText}>
-            Pagamentos seguros processados pelo Stripe
+            Pagamentos seguros processados pelo Mercado Pago
           </Text>
         </View>
       </ScrollView>
diff --git a/model.patch b/model.patch
index ec0cf9e..e69de29 100644
--- a/model.patch
+++ b/model.patch
@@ -1,199 +0,0 @@
-diff --git a/backend/server.py b/backend/server.py
-index fe57eda..d6504b5 100644
---- a/backend/server.py
-+++ b/backend/server.py
-@@ -2306,7 +2306,7 @@ async def create_checkout_session(
-         # Create payment transaction record
-         transaction = PaymentTransaction(
-             user_id=current_user.id,
--            session_id=session.session_id,
-+            session_id=session.id,
-             amount=package.price,
-             currency=package.currency,
-             payment_status="pending",
-@@ -2324,7 +2324,7 @@ async def create_checkout_session(
-         
-         return {
-             "url": session.url,
--            "session_id": session.session_id
-+            "session_id": session.id
-         }
-         
-     except HTTPException:
-@@ -2595,7 +2595,7 @@ async def create_corporate_checkout(request: CorporateCheckoutRequest):
-         # Create corporate payment transaction record
-         transaction = {
-             "id": str(uuid.uuid4()),
--            "session_id": session.session_id,
-+            "session_id": session.id,
-             "type": "corporate_license",
-             "company": request.company,
-             "contact_name": request.name, 
-@@ -2620,7 +2620,7 @@ async def create_corporate_checkout(request: CorporateCheckoutRequest):
-         return {
-             "success": True,
-             "checkout_url": session.url,
--            "session_id": session.session_id
-+            "session_id": session.id
-         }
-         
-     except HTTPException:
-diff --git a/model.patch b/model.patch
-index 5096193..e69de29 100644
---- a/model.patch
-+++ b/model.patch
-@@ -1,154 +0,0 @@
--diff --git a/backend/models/payments.py b/backend/models/payments.py
--index c97682a..5825433 100644
----- a/backend/models/payments.py
--+++ b/backend/models/payments.py
--@@ -6,8 +6,10 @@ from bson import ObjectId
-- class PaymentTransaction(BaseModel):
--     id: Optional[str] = Field(None, alias="_id")
--     user_id: Optional[str] = None
---    session_id: str
--+    session_id: Optional[str] = None  # For ebook purchases
--+    stripe_session_id: Optional[str] = None  # For subscription purchases
--     payment_id: Optional[str] = None
--+    plan_id: Optional[str] = None  # For subscription purchases
--     amount: float
--     currency: str = "brl"
--     payment_status: str = "pending"  # pending, paid, failed, expired
--diff --git a/backend/server.py b/backend/server.py
--index 1945664..9f5a88c 100644
----- a/backend/server.py
--+++ b/backend/server.py
--@@ -854,19 +854,20 @@ async def create_checkout_session(request: CreateCheckoutRequest, current_user:
--         transaction = PaymentTransaction(
--             user_id=current_user.id,
--             plan_id=request.plan_id,
---            stripe_session_id=session.session_id,
--+            stripe_session_id=session.id,
--             amount=plan['price'],
--             currency="brl",
--             payment_status="pending",
---            metadata=checkout_request.metadata
--+            metadata={
--+                "user_id": current_user.id,
--+                "plan_id": request.plan_id,
--+                "plan_name": plan['name']
--+            }
--         )
--         
--         await db.payment_transactions.insert_one(transaction.dict())
--         
---        return {
---            "url": session.url,
---            "session_id": session.session_id
---        }
--+        return {"checkout_url": session.url, "session_id": session.id}
--         
--     except HTTPException:
--         raise
--@@ -878,11 +879,11 @@ async def create_checkout_session(request: CreateCheckoutRequest, current_user:
-- async def get_checkout_status(session_id: str, current_user: User = Depends(get_current_user)):
--     """Get status of a checkout session"""
--     try:
---        # Initialize Stripe checkout
---        stripe_checkout = StripeCheckout(api_key=STRIPE_API_KEY, webhook_url="")
--+        if not STRIPE_API_KEY:
--+            raise HTTPException(status_code=500, detail="Stripe not configured")
--         
---        # Get checkout status from Stripe
---        status_response = await stripe_checkout.get_checkout_status(session_id)
--+        # Get checkout session from Stripe
--+        session = stripe.checkout.Session.retrieve(session_id)
--         
--         # Get current transaction
--         transaction = await db.payment_transactions.find_one({"stripe_session_id": session_id})
--@@ -891,7 +892,7 @@ async def get_checkout_status(session_id: str, current_user: User = Depends(get_
--             raise HTTPException(status_code=404, detail="Transaction not found")
--         
--         # If payment is completed but transaction is still pending, process it
---        if status_response.payment_status == "paid" and transaction.get("payment_status") == "pending":
--+        if session.payment_status == "paid" and transaction.get("payment_status") == "pending":
--             logger.info(f"Processing completed payment for session {session_id}")
--             
--             # Update transaction status
--@@ -911,20 +912,20 @@ async def get_checkout_status(session_id: str, current_user: User = Depends(get_
--                 logger.error(f"Failed to activate subscription for user {transaction['user_id']}")
--         
--         # Update transaction with current status if needed
---        elif transaction.get("payment_status") != status_response.payment_status:
--+        elif transaction.get("payment_status") != session.payment_status:
--             await db.payment_transactions.update_one(
--                 {"stripe_session_id": session_id},
--                 {"$set": {
---                    "payment_status": status_response.payment_status,
--+                    "payment_status": session.payment_status,
--                     "updated_at": datetime.utcnow()
--                 }}
--             )
--         
--         return {
---            "status": status_response.status,
---            "payment_status": status_response.payment_status,
---            "amount_total": status_response.amount_total,
---            "currency": status_response.currency
--+            "status": session.status,
--+            "payment_status": session.payment_status,
--+            "amount_total": session.amount_total,
--+            "currency": session.currency
--         }
--         
--     except Exception as e:
--@@ -938,31 +939,45 @@ async def stripe_webhook(request: Request):
--         body = await request.body()
--         stripe_signature = request.headers.get("Stripe-Signature")
--         
---        # Initialize Stripe checkout
---        stripe_checkout = StripeCheckout(api_key=STRIPE_API_KEY, webhook_url="")
--+        if not STRIPE_API_KEY:
--+            raise HTTPException(status_code=500, detail="Stripe not configured")
--         
---        # Handle webhook
---        webhook_response = await stripe_checkout.handle_webhook(body, stripe_signature)
--+        # For now, we'll handle webhooks manually without signature verification
--+        # In production, you should verify the webhook signature
--+        logger.info("Received Stripe webhook")
--         
---        # Update payment status based on webhook
---        if webhook_response.payment_status == "paid":
--+        # Parse the webhook event
--+        try:
--+            event = stripe.Event.construct_from(
--+                body.decode('utf-8'), STRIPE_API_KEY
--+            )
--+        except ValueError:
--+            logger.error("Invalid payload in webhook")
--+            raise HTTPException(status_code=400, detail="Invalid payload")
--+        
--+        # Handle the event
--+        if event['type'] == 'checkout.session.completed':
--+            session = event['data']['object']
--+            session_id = session['id']
--+            
--             # Find the transaction
--             transaction = await db.payment_transactions.find_one({
---                "stripe_session_id": webhook_response.session_id
--+                "stripe_session_id": session_id
--             })
--             
--             if transaction:
--                 # Update transaction status
--                 await db.payment_transactions.update_one(
---                    {"stripe_session_id": webhook_response.session_id},
--+                    {"stripe_session_id": session_id},
--                     {"$set": {
---                        "payment_status": webhook_response.payment_status,
--+                        "payment_status": "paid",
--                         "updated_at": datetime.utcnow()
--                     }}
--                 )
--                 
--                 # Activate subscription
--                 await activate_subscription(transaction['user_id'], transaction['plan_id'])
--+                logger.info(f"Subscription activated for user {transaction['user_id']}")
--         
--         return {"status": "success"}
--         
